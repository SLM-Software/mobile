import { Component, EventEmitter, forwardRef, HostListener, Input, Optional, Output, ViewEncapsulation } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { PickerController, Form, Item } from 'ionic-angular';
import _ from 'lodash';
import moment from 'moment';
import { MultiPickerTypeDate } from './types/date';
import { MultiPickerTypeTime } from './types/time';
import { MultiPickerColumn } from './multi-picker-columns';
export var MULTI_PICKER_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(function () { return MultiPicker; }),
    multi: true
};
export var MultiPicker = (function () {
    function MultiPicker(_form, _item, _pickerCtrl) {
        this._form = _form;
        this._item = _item;
        this._pickerCtrl = _pickerCtrl;
        this._disabled = false;
        this._labelId = '';
        this._text = '';
        this._isOpen = false;
        this.cancelText = 'Cancel';
        this.doneText = 'Done';
        this.type = 'time';
        this.min = moment().subtract(MultiPicker.YEAR_ROUND, 'year').startOf('year');
        this.max = moment().add(MultiPicker.YEAR_ROUND, 'year').endOf('year');
        this.minuteRounding = 1;
        this.ionChange = new EventEmitter();
        this.ionCancel = new EventEmitter();
        this._form.register(this);
        if (_item) {
            this.id = 'dt-' + _item.registerInput('multi-picker');
            this._labelId = 'lbl-' + _item['id'];
            this._item.setElementClass('item-multi-picker', true);
            this._value = this._value || '';
        }
    }
    Object.defineProperty(MultiPicker.prototype, "disabled", {
        get: function () {
            return this._disabled;
        },
        set: function (val) {
            this._disabled = val;
            this._item && this._item.setElementClass('item-multi-picker-disabled', this._disabled);
        },
        enumerable: true,
        configurable: true
    });
    MultiPicker.prototype.ngOnInit = function () {
        if (!this.displayFormat)
            this.displayFormat = this.displayFormat || this.type == 'date' ? 'DD.MM.YYYY' : 'HH:mm';
        if (!this.pickerFormat)
            this.pickerFormat = this.displayFormat || MultiPickerColumn.defaultFormat.pickerFormat;
    };
    MultiPicker.prototype.ngAfterContentInit = function () {
        this.setDateContext();
        this.convertLimits();
    };
    MultiPicker.prototype._click = function (ev) {
        if (ev.detail === 0) {
            return;
        }
        ev.preventDefault();
        ev.stopPropagation();
        this.open();
    };
    MultiPicker.prototype._keyup = function () {
        if (!this._isOpen) {
            this.open();
        }
    };
    MultiPicker.prototype.open = function () {
        var _this = this;
        this.setDateContext();
        this.convertLimits();
        if (this._disabled)
            return;
        var pickerOptions = {};
        var picker = this._pickerCtrl.create(pickerOptions);
        pickerOptions.buttons = [
            {
                text: this.cancelText,
                role: 'cancel',
                handler: function () {
                    _this.ionCancel.emit(null);
                }
            },
            {
                text: this.doneText,
                handler: function (data) {
                    _this.onChange(data);
                    _this.ionChange.emit(data);
                }
            }
        ];
        this.generate(picker);
        this.validateColumns(picker);
        picker.ionChange.subscribe(function () {
            _this.validateColumns(picker);
        });
        picker.present(pickerOptions);
        this._isOpen = true;
        picker.onDidDismiss(function () {
            _this._isOpen = false;
        });
    };
    MultiPicker.prototype.generate = function (picker) {
        var pickerFormat = this.pickerFormat;
        var commonParams = { pickerFormat: pickerFormat };
        if (this.type == 'date') {
            var _a = this, customFilterDays = _a.customFilterDays, weekends = _a.weekends;
            this.multiPickerType = new MultiPickerTypeDate(_.extend(commonParams, { customFilterDays: customFilterDays, weekends: weekends }));
        }
        else {
            var _b = this, min = _b.min, max = _b.max, minuteRounding = _b.minuteRounding;
            this.multiPickerType = new MultiPickerTypeTime(_.extend(commonParams, { min: min, max: max, minuteRounding: minuteRounding }));
        }
        _.each(this.multiPickerType.columns(), function (column) {
            picker.addColumn({
                name: column.name,
                options: column.options,
                selectedIndex: -1,
            });
        });
        this.divyColumns(picker);
    };
    MultiPicker.prototype.validateColumns = function (picker) {
        var columns = picker.getColumns();
        _.each(this.multiPickerType.columns(), function (column) {
            if (!column.options.length)
                MultiPicker.throw("column \"" + column.name + "\" should have at least one option");
        });
        if (this._isOpen)
            this.multiPickerType.validate(columns);
        else {
            this.multiPickerType.validate(columns, this._value);
            this.multiPickerType.setDefaultSelectedIndexes(picker.getColumns(), this._value);
        }
        this.multiPickerType.dealDoneVisibleBnt(columns, picker['data'].buttons[1]);
        picker.refresh();
    };
    MultiPicker.prototype.setDateContext = function () {
        var _this = this;
        this.dateContext = {};
        if (this.type == 'time') {
            var attr = moment(this.dateContextAttr) || moment();
            var dateContext = _.pick((this._value ? moment(this._value) : attr).toObject(), ['years', 'months', 'date']);
            var map_1 = { years: 'year', months: 'month', date: 'day' };
            _.each(dateContext, function (val, key) { return _this.dateContext[map_1[key]] = val; });
        }
    };
    MultiPicker.prototype.convertLimits = function () {
        var _this = this;
        ['min', 'max'].forEach(function (limit) {
            var momentLimit = moment(_this[limit]);
            _this[limit] = moment(_this.dateContext).set({ hour: momentLimit.hour(), minute: momentLimit.minute() });
        });
        if (this.type == 'time' && this.max.hours() == 0)
            this.max = this.max.endOf('date');
    };
    MultiPicker.prototype.divyColumns = function (picker) {
        var pickerColumns = picker.getColumns();
        var columns = [];
        pickerColumns.forEach(function (col, i) {
            columns.push(0);
            col.options.forEach(function (opt) {
                if (opt.text.replace(/[^\x00-\xff]/g, "01").length > columns[i]) {
                    columns[i] = opt.text.replace(/[^\x00-\xff]/g, "01").length;
                }
            });
        });
        if (columns.length === 2) {
            var width = Math.max(columns[0], columns[1]);
            pickerColumns[0].columnWidth = pickerColumns[1].columnWidth = width * 16 + "px";
        }
        else if (columns.length === 3) {
            var width = Math.max(columns[0], columns[2]);
            pickerColumns[1].columnWidth = columns[1] * 16 + "px";
            pickerColumns[0].columnWidth = pickerColumns[2].columnWidth = width * 16 + "px";
        }
        else if (columns.length > 3) {
            columns.forEach(function (col, i) {
                pickerColumns[i].columnWidth = col * 12 + "px";
            });
        }
    };
    MultiPicker.prototype.setValue = function (newData) {
        if (newData === null || newData === undefined) {
            this._value = '';
        }
        else {
            this._value = newData;
        }
    };
    MultiPicker.prototype.checkHasValue = function (inputValue) {
        if (this._item) {
            this._item.setElementClass('input-has-value', !!(inputValue && inputValue !== ''));
        }
    };
    MultiPicker.prototype.updateText = function () {
        this._text = this._value ? moment(this._value).format(this.displayFormat) : '';
    };
    MultiPicker.prototype.convertObjectToString = function (newData) {
        var newMomentObj = {};
        _.each(newData, function (timepart, name) { return newMomentObj[name] = timepart.value; });
        if (newMomentObj.months)
            newMomentObj.months = newMomentObj.months - 1;
        _.extend(newMomentObj, this.dateContext);
        return _.isEmpty(newMomentObj) ? '' : moment(newMomentObj).format();
    };
    MultiPicker.throw = function (msg) {
        throw "Ion2 datetime picker: " + msg;
    };
    MultiPicker.prototype.writeValue = function (val) {
        this.setValue(val);
        this.updateText();
        this.checkHasValue(val);
    };
    MultiPicker.prototype.registerOnChange = function (fn) {
        var _this = this;
        this._fn = fn;
        this.onChange = function (val) {
            _this.setValue(_this.convertObjectToString(val));
            _this.updateText();
            _this.checkHasValue(val);
            fn(_this._value);
            _this.onTouched();
        };
    };
    MultiPicker.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };
    MultiPicker.prototype.ngOnDestroy = function () {
        this._form.deregister(this);
    };
    MultiPicker.prototype.onChange = function (val) {
        this.setValue(this.convertObjectToString(val));
        this.updateText();
        this.onTouched();
    };
    MultiPicker.prototype.onTouched = function () { };
    MultiPicker.YEAR_ROUND = 2;
    MultiPicker.decorators = [
        { type: Component, args: [{
                    selector: 'ion-multi-picker',
                    template: '<div class="multi-picker-text">{{_text}}</div>' +
                        '<button aria-haspopup="true" ' +
                        'type="button" ' +
                        '[id]="id" ' +
                        'ion-button="item-cover" ' +
                        '[attr.aria-labelledby]="_labelId" ' +
                        '[attr.aria-disabled]="_disabled" ' +
                        'class="item-cover">' +
                        '</button>',
                    host: {
                        '[class.multi-picke-disabled]': '_disabled'
                    },
                    providers: [MULTI_PICKER_VALUE_ACCESSOR, Form],
                    encapsulation: ViewEncapsulation.None,
                },] },
    ];
    MultiPicker.ctorParameters = [
        { type: Form, },
        { type: Item, decorators: [{ type: Optional },] },
        { type: PickerController, decorators: [{ type: Optional },] },
    ];
    MultiPicker.propDecorators = {
        'cancelText': [{ type: Input },],
        'doneText': [{ type: Input },],
        'formControl': [{ type: Input },],
        'customFilterDays': [{ type: Input, args: ['filterDays',] },],
        'dateContextAttr': [{ type: Input, args: ['dateContext',] },],
        'weekends': [{ type: Input },],
        'type': [{ type: Input },],
        'displayFormat': [{ type: Input },],
        'pickerFormat': [{ type: Input },],
        'min': [{ type: Input },],
        'max': [{ type: Input },],
        'minuteRounding': [{ type: Input },],
        'disabled': [{ type: Input },],
        'ionChange': [{ type: Output },],
        'ionCancel': [{ type: Output },],
        '_click': [{ type: HostListener, args: ['click', ['$event'],] },],
        '_keyup': [{ type: HostListener, args: ['keyup.space',] },],
    };
    return MultiPicker;
}());
//# sourceMappingURL=multi-picker.js.map